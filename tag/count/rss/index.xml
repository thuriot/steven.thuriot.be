<?xml version="1.0" encoding="UTF-8"?> <rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"> <channel> <title><![CDATA[Steven Thuriot.be &mdash; Count]]></title> <description><![CDATA[Thoughts, stories and ideas.]]></description> <link>http://localhost:4000</link> <link href="http://localhost:4000/tag/count/rss/" rel="self" type="application/rss+xml"/> <ttl>60</ttl> <item> <title><![CDATA[Avoid Count() methods]]></title> <description><![CDATA[At work I&#39;m currently working with [dotTrace](http://www.jetbrains.com/profiler/) to check the performance of our application. A few of our issues were quickly traced back to the faulty usage of the Count() extension method. ]]></description> <link>http://localhost:4000/avoid-count-methods</link> <guid isPermaLink="true">http://localhost:4000/avoid-count-methods</guid> <pubDate>2011-08-22T18:50:00+00:00</pubDate> <content:encoded><![CDATA[<p>At work I&#39;m currently working with <a href="http://www.jetbrains.com/profiler/">dotTrace</a> to check the performance of our application. A few of our issues were quickly traced back to the faulty usage of the Count() extension method.</p> <p>Count() should be avoided as much as possible on IEnumerables. Count() is optimized to check for Count or Length properties, but if the used list doesn&#39;t have these implemented, Count() will iterate the entire list. We have a few fairly large lists in our application, so that quickly consumes quite a bit of time to run all the Count()&#39;s. Unless you&#39;re interested in the exact size of your list, I would say to avoid this method at all costs. However, even in this case there are a few better options.</p> <p>The most interesting option is to check with what kind of list you&#39;re working with. Lists like Collection, Array, List, ... either have a Length or Count property. This property is just a simple int that is already stored in the memory. It doesn&#39;t get much faster than this. The cost of calling these properties is neglectable. If the full size of your list is really important for your use case, it might pay off to switch to one of these types of lists.</p> <p>In case you&#39;re not interested in the full size of the list and don&#39;t want to or can&#39;t use a list that implements one of these properties, don&#39;t worry, there are a few other tips and tricks to handle these. I noticed that most of the time, Count() is used to check if there are any items in the list (<strong>Count() &gt; 0 , != 0 or == 0</strong> ). In this case it&#39;s much more interesting to use the LINQ Any() extension method. This method will check if there is one item in the list and return the result as a boolean. On a big list, you gain quite a bit of performance. Another common misusage of Count() is <strong>Where(...).Count() &gt; 0</strong>. In this case, it&#39;s far better to use <strong>Any(...)</strong>. In case 0 isn&#39;t the number you&#39;re checking against, it&#39;s still better to use <strong>Count(...)</strong>Â  instead and drop <strong>Where(...)</strong>. Since <strong>Where</strong> is lazy, it won&#39;t matter much for performance, but I find that the readability of what you are trying to do is increased greatly.</p> <p>For all the other cases, I wrote a few extension methods so it&#39;s possible to completely avoid using Count(). The idea behind these extension methods is that the list you&#39;re checking usually has a lot more items in it than the number you&#39;re checking against, for instance <strong>&gt; 2</strong> on a list of 300 items. On these kinds of checks, my extension methods truly shine. Rather than counting the whole list, they count x+1 items from the list, where x is the number you&#39;re checking against. You don&#39;t need to do any more counting than x+1 as you can check any of the conditions with this amount. This way, the actual counting is reduced greatly. When used correctly, the average cost will be a lot lower than using <strong>Count()</strong>. All of the extension methods also have an overload to allow you to specify a <strong>Where(...)</strong> clause so it can do everything in one go, rather than having to do a <strong>Where(...)</strong> first and a <strong>Count()</strong> after.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;comparePredicate&quot;&gt;The comparison function.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;The result of the passed predicate.&lt;/returns&gt;</span>
<span class="k">private</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">OptimizedCount</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">comparePredicate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enumerable</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">numberOfItems</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">wherePredicate</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">enumerable</span> <span class="p">=</span> <span class="n">enumerable</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">wherePredicate</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">var</span> <span class="n">numberOfItemsToCount</span> <span class="p">=</span> <span class="k">checked</span><span class="p">(</span><span class="n">numberOfItems</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">countedItems</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">enumerator</span> <span class="p">=</span> <span class="n">enumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">enumerator</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">()</span> <span class="p">&amp;</span><span class="n">amp</span><span class="p">;&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">countedItems</span> <span class="p">&lt;</span> <span class="n">numberOfItemsToCount</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">countedItems</span><span class="p">++;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">returnValue</span> <span class="p">=</span> <span class="n">comparePredicate</span><span class="p">(</span><span class="n">countedItems</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">returnValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">)</span>
<span class="p">{</span>
Â Â  Â <span class="k">return</span> <span class="n">CountEqualTo</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate to apply to the list.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">)</span>
<span class="p">{</span>
Â Â  Â <span class="k">return</span> <span class="n">OptimizedCount</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">wherePredicate</span><span class="p">,</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">==</span> <span class="n">numberOfItems</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains less items than defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="na">[SuppressMessage(&quot;Microsoft.Naming&quot;, &quot;CA1702:CompoundWordsShouldBeCasedCorrectly&quot;, MessageId = &quot;CountLess&quot;)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountLessThan</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">)</span>
<span class="p">{</span>
Â Â  Â <span class="k">return</span> <span class="n">CountLessThan</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate to apply to the list.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains less items than defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="na">[SuppressMessage(&quot;Microsoft.Naming&quot;, &quot;CA1702:CompoundWordsShouldBeCasedCorrectly&quot;, MessageId = &quot;CountLess&quot;)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountLessThan</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">)</span>
<span class="p">{</span>
Â Â  Â <span class="k">return</span> <span class="n">OptimizedCount</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">wherePredicate</span><span class="p">,</span>  <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">numberOfItems</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains more items than defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountGreaterThan</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">)</span>
<span class="p">{</span>
Â Â  Â <span class="k">return</span> <span class="n">CountGreaterThan</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate to apply to the list.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains more items than defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountGreaterThan</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">)</span>
<span class="p">{</span>
Â Â  Â <span class="k">return</span> <span class="n">OptimizedCount</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">wherePredicate</span><span class="p">,</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">&gt;</span> <span class="n">numberOfItems</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains less or the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="na">[SuppressMessage(&quot;Microsoft.Naming&quot;, &quot;CA1702:CompoundWordsShouldBeCasedCorrectly&quot;, MessageId = &quot;CountLess&quot;)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountLessOrEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">)</span>
<span class="p">{</span>
Â Â  Â <span class="k">return</span> <span class="n">CountLessOrEqualTo</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate to apply to the list.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains less or the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="na">[SuppressMessage(&quot;Microsoft.Naming&quot;, &quot;CA1702:CompoundWordsShouldBeCasedCorrectly&quot;, MessageId = &quot;CountLess&quot;)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountLessOrEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">)</span>
<span class="p">{</span>
Â Â  Â <span class="k">return</span> <span class="n">OptimizedCount</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">wherePredicate</span><span class="p">,</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">&lt;=</span> <span class="n">numberOfItems</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains more or the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountGreaterOrEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">)</span>
<span class="p">{</span>
Â Â  Â <span class="k">return</span> <span class="n">CountGreaterOrEqualTo</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate to apply to the list.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains more or the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountGreaterOrEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">)</span>
<span class="p">{</span>
Â Â  Â <span class="k">return</span> <span class="n">OptimizedCount</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">wherePredicate</span><span class="p">,</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">&gt;=</span> <span class="n">numberOfItems</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> <p>A few more tips and tricks regarding <strong>Count()</strong>&#39;s. Do not use them in the check condition of for-loops. It will be executed every loop, causing a severe performance issue.</p> <p>Another, in my opinion, interesting optimization is the following one:</p> <p>Original code where the sublist is a Collection:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">number</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">SelectMany</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">SubList</span><span class="p">).</span><span class="n">Count</span><span class="p">();</span>
</code></pre></div> <p>Optimized code:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">number</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">SubList</span><span class="p">.</span><span class="n">Count</span><span class="p">);</span>
</code></pre></div> <p>This way it will only make the sum of a few integers, which is much faster than creating one big list in memory, then count all the items.</p> ]]></content:encoded> </item> </channel> </rss>