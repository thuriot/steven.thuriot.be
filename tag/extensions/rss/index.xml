<?xml version="1.0" encoding="UTF-8"?> <rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"> <channel> <title><![CDATA[Steven Thuriot.be &mdash; Extensions]]></title> <description><![CDATA[Thoughts, stories and ideas.]]></description> <link>http://steven.thuriot.be</link> <link href="//steven.thuriot.be/tag/extensions/rss/" rel="self" type="application/rss+xml"/> <ttl>60</ttl> <item> <title><![CDATA[Playing with Sets]]></title> <description><![CDATA[The [`Distinct`](https://msdn.microsoft.com/en-us/library/vstudio/bb348436.aspx) method is one of the really useful methods in the `System.Linq` namespace. Internally, it&#39;s really simple, too. It will just iterate your collection and add them all to a [`HashSet`](https://msdn.microsoft.com/en-us/library/bb359438.aspx). The set will make sure that each item is only added once on its own. Instead of adding all items and returning just the set, `Distinct` will actually create an iterator that will return the item if successfully added. While this is a good idea since the actual execution is deferred, at times it is nice to just create the set and keep working with it, instead. While this is simple enough as is, I created an extension method anyway. ```csharp public static HashSet&lt;T&gt; ToSet&lt;T&gt;(this IEnumerable&lt;T&gt; source) { return new HashSet&lt;T&gt;(source); } ``` It&#39;s a bit too simple to post, really. One could argue it&#39;s too simple to exist, even. And frankly, it is. So we&#39;ll go a step further, and allow creating the set based on a key. ```csharp public static HashSet&lt;T&gt; ToSet&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector) { return new HashSet&lt;T&gt;(source, keySelector.AsComparer()); } ``` Continuing the `LINQ` way of thinking, it would be nice to just pass a `Func` along to the method to create the key. However, `HashSet` doesn&#39;t accept this and wants a comparer instead. So let&#39;s create a comparer that will wrap around our `Func`! ```csharp public static class FunctorComparerExtensions { public static FunctorComparer&lt;T&gt; AsComparer&lt;T, TKey&gt;(this Func&lt;T, TKey&gt; keySelector) { var comparer=Comparer&lt;TKey&gt;.Default; Comparison&lt;T&gt; comparison=(x, y) =&gt; comparer.Compare(keySelector(x), keySelector(y)); return comparison.AsComparer(); } public static FunctorComparer&lt;T&gt; AsComparer&lt;T&gt;(this Comparison&lt;T&gt; comparison) { return new FunctorComparer&lt;T&gt;(comparison); } } sealed class FunctorComparer&lt;T&gt; : IEqualityComparer&lt;T&gt;, IComparer&lt;T&gt; { readonly Comparison&lt;T&gt; _comparison; public FunctorComparer(Comparison&lt;T&gt; comparison) { _comparison=comparison; } public int Compare(T x, T y) { return _comparison(x, y); } public bool Equals(T x, T y) { return Compare(x, y) == 0; } public int GetHashCode(T obj) { return obj.GetHashCode(); } } ``` Now our key will be able to be used for both comparisons as equality. Usage is quite simple! ```csharp var set=list.Where(x =&gt; x.SomeCondition == true).ToSet(x =&gt; x.KeyProperty); ``` ]]></description> <link>//steven.thuriot.be/playing-with-sets</link> <guid isPermaLink="true">//steven.thuriot.be/playing-with-sets</guid> <pubDate>2015-10-08T17:29:00+00:00</pubDate> <media:content url="//cdn.thuriot.be/images/Covers/color-paint-cans.jpg" medium="image"/> <content:encoded><![CDATA[<p>The <a href="https://msdn.microsoft.com/en-us/library/vstudio/bb348436.aspx"><code>Distinct</code></a> method is one of the really useful methods in the <code>System.Linq</code> namespace. Internally, it&#39;s really simple, too. It will just iterate your collection and add them all to a <a href="https://msdn.microsoft.com/en-us/library/bb359438.aspx"><code>HashSet</code></a>. The set will make sure that each item is only added once on its own.</p> <p>Instead of adding all items and returning just the set, <code>Distinct</code> will actually create an iterator that will return the item if successfully added. While this is a good idea since the actual execution is deferred, at times it is nice to just create the set and keep working with it, instead.</p> <p>While this is simple enough as is, I created an extension method anyway.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">static</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ToSet</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">source</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> <p>It&#39;s a bit too simple to post, really. One could argue it&#39;s too simple to exist, even. And frankly, it is. So we&#39;ll go a step further, and allow creating the set based on a key.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">static</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ToSet</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">source</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">TKey</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">source</span><span class="p">,</span> <span class="n">keySelector</span><span class="p">.</span><span class="n">AsComparer</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div> <p>Continuing the <code>LINQ</code> way of thinking, it would be nice to just pass a <code>Func</code> along to the method to create the key. However, <code>HashSet</code> doesn&#39;t accept this and wants a comparer instead. So let&#39;s create a comparer that will wrap around our <code>Func</code>!</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">FunctorComparerExtensions</span>
<span class="p">{</span>
   <span class="k">public</span> <span class="k">static</span> <span class="n">FunctorComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">AsComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">TKey</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">TKey</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">)</span>
   <span class="p">{</span>
       <span class="kt">var</span> <span class="n">comparer</span> <span class="p">=</span> <span class="n">Comparer</span><span class="p">&lt;</span><span class="n">TKey</span><span class="p">&gt;.</span><span class="n">Default</span><span class="p">;</span>
       <span class="n">Comparison</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">comparison</span> <span class="p">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">comparer</span><span class="p">.</span><span class="n">Compare</span><span class="p">(</span><span class="n">keySelector</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">keySelector</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
       <span class="k">return</span> <span class="n">comparison</span><span class="p">.</span><span class="n">AsComparer</span><span class="p">();</span>
   <span class="p">}</span>

   <span class="k">public</span> <span class="k">static</span> <span class="n">FunctorComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">AsComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">Comparison</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">comparison</span><span class="p">)</span>
   <span class="p">{</span>
       <span class="k">return</span> <span class="k">new</span> <span class="n">FunctorComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">comparison</span><span class="p">);</span>
   <span class="p">}</span>

<span class="p">}</span>

<span class="k">sealed</span> <span class="k">class</span> <span class="nc">FunctorComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IEqualityComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="n">IComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">readonly</span> <span class="n">Comparison</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_comparison</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">FunctorComparer</span><span class="p">(</span><span class="n">Comparison</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">comparison</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_comparison</span> <span class="p">=</span> <span class="n">comparison</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="nf">Compare</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nf">_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Compare</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">==</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">(</span><span class="n">T</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">GetHashCode</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>Now our key will be able to be used for both comparisons as equality.</p> <p>Usage is quite simple!</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="k">set</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">SomeCondition</span> <span class="p">==</span> <span class="k">true</span><span class="p">).</span><span class="n">ToSet</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">KeyProperty</span><span class="p">);</span>
</code></pre></div>]]></content:encoded> </item> </channel> </rss>