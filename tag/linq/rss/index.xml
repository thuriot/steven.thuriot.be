<?xml version="1.0" encoding="UTF-8"?> <rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"> <channel> <title><![CDATA[Steven Thuriot.be &mdash; LINQ]]></title> <description><![CDATA[Thoughts, stories and ideas.]]></description> <link>http://localhost:4000</link> <link href="http://localhost:4000/tag/linq/rss/" rel="self" type="application/rss+xml"/> <ttl>60</ttl> <item> <title><![CDATA[Guard your code using LINQ and Reflection]]></title> <description><![CDATA[Time to add another class to our Helpers. ]]></description> <link>http://localhost:4000/guard-your-code-using-linq-and-reflection</link> <guid isPermaLink="true">http://localhost:4000/guard-your-code-using-linq-and-reflection</guid> <pubDate>2010-12-23T10:13:00+00:00</pubDate> <content:encoded><![CDATA[<p>Time to add another class to our Helpers.</p> <p>Defensive programming is very important. Checking that every parameter is correct before working with them is simply a must. The code for doing something like this quickly becomes very repetitive. Writing a Guard class is the perfect way to keep everything in check and avoid duplicate code.</p> <p>I decided to even take it a step further and use reflection to get the name of the method and the parameters where things are starting to go wrong and add them to the exception&#39;s message as extra information. The checks themselves are done using LINQ.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Globalization</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reflection</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Text</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Helpers.Extensions</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Helpers</span>
<span class="p">{</span>
    <span class="c1">///&lt;summary&gt;</span>
    <span class="c1">/// Helper to make sure the passed parameters are correct.</span>
    <span class="c1">///&lt;/summary&gt;</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Guard</span>
    <span class="p">{</span>

        <span class="c1">///&lt;summary&gt;</span>
        <span class="c1">/// Determines whether the typeToAssign can be assigned to the targetType</span>
        <span class="c1">///&lt;/summary&gt;</span>
        <span class="c1">///&lt;param name=&quot;typeToAssign&quot;&gt;The type to assign.&lt;/param&gt;</span>
        <span class="c1">///&lt;param name=&quot;targetType&quot;&gt;Type of the target.&lt;/param&gt;</span>
        <span class="c1">///&lt;exception cref=&quot;ArgumentException&quot;&gt;The types can&#39;t be assigned.&lt;/exception&gt;</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">CanBeAssigned</span><span class="p">(</span><span class="n">Type</span> <span class="n">typeToAssign</span><span class="p">,</span> <span class="n">Type</span> <span class="n">targetType</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">typeToAssign</span><span class="p">.</span><span class="n">CanBeAssignedTo</span><span class="p">(</span><span class="n">targetType</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="n">CultureInfo</span><span class="p">.</span><span class="n">CurrentCulture</span><span class="p">,</span> <span class="n">targetType</span><span class="p">.</span><span class="n">IsInterface</span> <span class="p">?</span>
                    <span class="s">&quot;Type {0} can not be assigned to {1}: interface is not implemented.&quot;</span> <span class="p">:</span>
                    <span class="s">&quot;Type {0} can not be assigned to {1}.&quot;</span><span class="p">,</span> <span class="n">typeToAssign</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">targetType</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>

                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">///&lt;summary&gt;</span>
        <span class="c1">/// Checks the guids to ensure they are not empty.</span>
        <span class="c1">///&lt;/summary&gt;</span>
        <span class="c1">///&lt;param name=&quot;arguments&quot;&gt;The arguments.&lt;/param&gt;</span>
        <span class="c1">///&lt;exception cref=&quot;ArgumentException&quot;&gt;Some of the guids are empty.&lt;/exception&gt;</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">GuidNotEmpty</span><span class="p">(</span><span class="k">params</span> <span class="n">Guid</span><span class="p">[]</span> <span class="n">arguments</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Boolean</span> <span class="n">faultyArguments</span> <span class="p">=</span> <span class="p">(</span><span class="k">from</span> <span class="n">t</span> <span class="k">in</span> <span class="n">arguments</span>
                                       <span class="k">where</span> <span class="n">t</span> <span class="p">==</span> <span class="n">Guid</span><span class="p">.</span><span class="n">Empty</span>
                                       <span class="k">select</span> <span class="n">t</span><span class="p">).</span><span class="n">Any</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">faultyArguments</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">MethodBase</span> <span class="n">methodBase</span> <span class="p">=</span> <span class="n">GetCallingMethod</span><span class="p">();</span>
                <span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="s">&quot;Some guids are empty: &quot;</span> <span class="p">+</span>
                    <span class="n">CreateMethodMessage</span><span class="p">(</span><span class="n">methodBase</span><span class="p">,</span> <span class="n">arguments</span><span class="p">.</span><span class="n">ToObjectArray</span><span class="p">());</span>

                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">///&lt;summary&gt;</span>
        <span class="c1">/// Checks the dates to ensure they are in the future.</span>
        <span class="c1">///&lt;/summary&gt;</span>
        <span class="c1">///&lt;param name=&quot;arguments&quot;&gt;The arguments.&lt;/param&gt;</span>
        <span class="c1">///&lt;exception cref=&quot;ArgumentException&quot;&gt;Some of the dates are in the past.&lt;/exception&gt;</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">InTheFuture</span><span class="p">(</span><span class="k">params</span> <span class="n">DateTime</span><span class="p">[]</span> <span class="n">arguments</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Boolean</span> <span class="n">faultyArguments</span> <span class="p">=</span> <span class="p">(</span><span class="k">from</span> <span class="n">t</span> <span class="k">in</span> <span class="n">arguments</span>
                                       <span class="k">where</span> <span class="p">!</span><span class="n">t</span><span class="p">.</span><span class="n">InTheFuture</span><span class="p">()</span>
                                       <span class="k">select</span> <span class="n">t</span><span class="p">).</span><span class="n">Any</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">faultyArguments</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">MethodBase</span> <span class="n">methodBase</span> <span class="p">=</span> <span class="n">GetCallingMethod</span><span class="p">();</span>
                <span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="s">&quot;Not all passed dates are in the past: &quot;</span> <span class="p">+</span>
                    <span class="n">CreateMethodMessage</span><span class="p">(</span><span class="n">methodBase</span><span class="p">,</span> <span class="n">arguments</span><span class="p">.</span><span class="n">ToObjectArray</span><span class="p">());</span>

                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">///&lt;summary&gt;</span>
        <span class="c1">/// Checks the dates to ensure they are in the past.</span>
        <span class="c1">///&lt;/summary&gt;</span>
        <span class="c1">///&lt;param name=&quot;arguments&quot;&gt;The arguments.&lt;/param&gt;</span>
        <span class="c1">///&lt;exception cref=&quot;ArgumentException&quot;&gt;Some of the dates are in the future.&lt;/exception&gt;</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">InThePast</span><span class="p">(</span><span class="k">params</span> <span class="n">DateTime</span><span class="p">[]</span> <span class="n">arguments</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Boolean</span> <span class="n">faultyArguments</span> <span class="p">=</span> <span class="p">(</span><span class="k">from</span> <span class="n">t</span> <span class="k">in</span> <span class="n">arguments</span>
                                       <span class="k">where</span> <span class="p">!</span><span class="n">t</span><span class="p">.</span><span class="n">InThePast</span><span class="p">()</span>
                                       <span class="k">select</span> <span class="n">t</span><span class="p">).</span><span class="n">Any</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">faultyArguments</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">MethodBase</span> <span class="n">methodBase</span> <span class="p">=</span> <span class="n">GetCallingMethod</span><span class="p">();</span>
                <span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="s">&quot;Not all passed dates are in the past: &quot;</span> <span class="p">+</span>
                    <span class="n">CreateMethodMessage</span><span class="p">(</span><span class="n">methodBase</span><span class="p">,</span> <span class="n">arguments</span><span class="p">.</span><span class="n">ToObjectArray</span><span class="p">());</span>

                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">///&lt;summary&gt;</span>
        <span class="c1">/// Checks the arguments to ensure they aren&#39;t null.</span>
        <span class="c1">///&lt;/summary&gt;</span>
        <span class="c1">///&lt;param name=&quot;arguments&quot;&gt;The arguments.&lt;/param&gt;</span>
        <span class="c1">///&lt;exception cref=&quot;ArgumentException&quot;&gt;Some of the arguments are null.&lt;/exception&gt;</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">NotNull</span><span class="p">(</span><span class="k">params</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">arguments</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Boolean</span> <span class="n">faultyArguments</span><span class="p">;</span>

            <span class="k">try</span>
            <span class="p">{</span>
                <span class="n">faultyArguments</span> <span class="p">=</span> <span class="p">(</span><span class="k">from</span> <span class="n">t</span> <span class="k">in</span> <span class="n">arguments</span>
                                        <span class="k">where</span> <span class="n">t</span> <span class="p">==</span> <span class="k">null</span>
                                           <span class="k">select</span> <span class="n">t</span><span class="p">).</span><span class="n">Any</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">(</span><span class="n">ArgumentNullException</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">faultyArguments</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">faultyArguments</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">MethodBase</span> <span class="n">methodBase</span> <span class="p">=</span> <span class="n">GetCallingMethod</span><span class="p">();</span>
                <span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="s">&quot;&lt;NULL&gt; has been passed: &quot;</span> <span class="p">+</span>
                    <span class="n">CreateMethodMessage</span><span class="p">(</span><span class="n">methodBase</span><span class="p">,</span> <span class="n">arguments</span><span class="p">);</span>

                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">///&lt;summary&gt;</span>
        <span class="c1">/// Checks the arguments to ensure they aren&#39;t null, empty or whitespace.</span>
        <span class="c1">///&lt;/summary&gt;</span>
        <span class="c1">///&lt;param name=&quot;arguments&quot;&gt;The arguments.&lt;/param&gt;</span>
        <span class="c1">///&lt;exception cref=&quot;ArgumentException&quot;&gt;Some of the arguments are null, empty or whitespace.&lt;/exception&gt;</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">NotNullOrWhiteSpace</span><span class="p">(</span><span class="k">params</span> <span class="n">String</span><span class="p">[]</span> <span class="n">arguments</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Boolean</span> <span class="n">faultyArguments</span><span class="p">;</span>

            <span class="k">try</span>
            <span class="p">{</span>
                <span class="n">faultyArguments</span> <span class="p">=</span> <span class="p">(</span><span class="k">from</span> <span class="n">t</span> <span class="k">in</span> <span class="n">arguments</span>
                                   <span class="k">where</span> <span class="n">t</span><span class="p">.</span><span class="n">IsNullOrWhiteSpace</span><span class="p">()</span>
                                   <span class="k">select</span> <span class="n">t</span><span class="p">).</span><span class="n">Any</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">(</span><span class="n">ArgumentNullException</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">faultyArguments</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">faultyArguments</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">MethodBase</span> <span class="n">methodBase</span> <span class="p">=</span> <span class="n">GetCallingMethod</span><span class="p">();</span>
                <span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="s">&quot;&lt;NULL&gt;, empty or whitespace has been passed: &quot;</span> <span class="p">+</span>
                    <span class="n">CreateMethodMessage</span><span class="p">(</span><span class="n">methodBase</span><span class="p">,</span> <span class="n">arguments</span><span class="p">);</span>

                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">///&lt;summary&gt;</span>
        <span class="c1">/// Checks if the start datetime is before the end datetime.</span>
        <span class="c1">///&lt;/summary&gt;</span>
        <span class="c1">///&lt;param name=&quot;start&quot;&gt;The start datetime.&lt;/param&gt;</span>
        <span class="c1">///&lt;param name=&quot;end&quot;&gt;The end datetime.&lt;/param&gt;</span>
        <span class="c1">///&lt;exception cref=&quot;ArgumentException&quot;&gt;The start datetime is after or equal to end datetime.&lt;/exception&gt;</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">StartBeforeEnd</span><span class="p">(</span><span class="n">DateTime</span> <span class="n">start</span><span class="p">,</span> <span class="n">DateTime</span> <span class="n">end</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">start</span><span class="p">.</span><span class="n">IsBefore</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">MethodBase</span> <span class="n">methodBase</span> <span class="p">=</span> <span class="n">GetCallingMethod</span><span class="p">();</span>
                <span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="s">&quot;The start datetime is after or equal to end datetime: &quot;</span> <span class="p">+</span>
                    <span class="n">CreateMethodMessage</span><span class="p">(</span><span class="n">methodBase</span><span class="p">,</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[]</span> <span class="p">{</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="p">});</span>

                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">///&lt;summary&gt;</span>
        <span class="c1">/// Gets the calling method.</span>
        <span class="c1">///&lt;/summary&gt;</span>
        <span class="c1">///&lt;returns&gt;&lt;/returns&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="n">MethodBase</span> <span class="nf">GetCallingMethod</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">MethodBase</span> <span class="n">result</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">currentStackTrace</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StackTrace</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>

            <span class="kt">int</span> <span class="n">totalFrameCount</span> <span class="p">=</span> <span class="n">currentStackTrace</span><span class="p">.</span><span class="n">FrameCount</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">totalFrameCount</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">result</span> <span class="p">=</span> <span class="n">currentStackTrace</span><span class="p">.</span><span class="n">GetFrame</span><span class="p">(</span><span class="m">0</span><span class="p">).</span><span class="n">GetMethod</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">///&lt;summary&gt;</span>
        <span class="c1">/// Creates the message.</span>
        <span class="c1">///&lt;/summary&gt;</span>
        <span class="c1">///&lt;param name=&quot;methodBase&quot;&gt;The method base.&lt;/param&gt;</span>
        <span class="c1">///&lt;param name=&quot;arguments&quot;&gt;The arguments.&lt;/param&gt;</span>
        <span class="c1">///&lt;returns&gt;&lt;/returns&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">CreateMethodMessage</span><span class="p">(</span><span class="n">MethodBase</span> <span class="n">methodBase</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">arguments</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">prefix</span> <span class="p">=</span> <span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="n">CultureInfo</span><span class="p">.</span><span class="n">CurrentCulture</span><span class="p">,</span> <span class="s">&quot;Class: {0} - Method: {1} - Args: &quot;</span><span class="p">,</span>
                <span class="p">!</span><span class="n">methodBase</span><span class="p">.</span><span class="n">IsNull</span><span class="p">()</span> <span class="p">?</span>
                <span class="n">methodBase</span><span class="p">.</span><span class="n">DeclaringType</span><span class="p">.</span><span class="n">FullName</span> <span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="p">!</span><span class="n">methodBase</span><span class="p">.</span><span class="n">IsNull</span><span class="p">()</span> <span class="p">?</span> <span class="n">methodBase</span><span class="p">.</span><span class="n">Name</span> <span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

            <span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">prefix</span><span class="p">);</span>

            <span class="kt">int</span> <span class="n">paramLength</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">printArgumentNames</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">ParameterInfo</span><span class="p">[]</span> <span class="n">methodParameters</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">arguments</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">paramLength</span> <span class="p">=</span> <span class="n">arguments</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">methodBase</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">methodParameters</span> <span class="p">=</span> <span class="n">methodBase</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">methodParameters</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="n">paramLength</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">printArgumentNames</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">arguments</span><span class="p">.</span><span class="n">IsNullOrEmpty</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span> <span class="n">arguments</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">printArgumentNames</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">methodParameters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Name</span><span class="p">);</span>
                        <span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&quot; = &quot;</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">);</span>

                    <span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">?</span> <span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ToString</span><span class="p">()</span> <span class="p">:</span> <span class="s">&quot;NULL&quot;</span><span class="p">);</span>

                    <span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&quot;]&quot;</span><span class="p">);</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">!=</span> <span class="n">arguments</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&quot;No arguments&quot;</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">builder</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>The code is very easy to use. Here are some sample methods:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="k">void</span> <span class="nf">NullMethod</span><span class="p">(</span><span class="kt">object</span> <span class="n">object1</span><span class="p">,</span> <span class="kt">object</span> <span class="n">object2</span><span class="p">,</span> <span class="kt">object</span> <span class="n">object3</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Helpers</span><span class="p">.</span><span class="n">Guard</span><span class="p">.</span><span class="n">NotNull</span><span class="p">(</span><span class="n">object1</span><span class="p">,</span> <span class="n">object2</span><span class="p">,</span> <span class="n">object3</span><span class="p">);</span>

    <span class="c1">//further logic</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">StringsMethod</span><span class="p">(</span><span class="n">String</span> <span class="n">firstName</span><span class="p">,</span> <span class="n">String</span> <span class="n">lastName</span><span class="p">,</span> <span class="n">String</span> <span class="n">residence</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Helpers</span><span class="p">.</span><span class="n">Guard</span><span class="p">.</span><span class="n">NotNullOrWhiteSpace</span><span class="p">(</span><span class="n">firstName</span><span class="p">,</span> <span class="n">lastName</span><span class="p">,</span> <span class="n">residence</span><span class="p">);</span>

    <span class="c1">//further logic</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">GuidMethod</span><span class="p">(</span><span class="kt">string</span> <span class="n">firstGuid</span><span class="p">,</span> <span class="kt">string</span> <span class="n">secondGuid</span><span class="p">,</span> <span class="kt">string</span> <span class="n">thirdGuid</span><span class="p">,</span> <span class="kt">string</span> <span class="n">fourthGuid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Helpers</span><span class="p">.</span><span class="n">Guard</span><span class="p">.</span><span class="n">ParsableToGuid</span><span class="p">(</span><span class="n">firstGuid</span><span class="p">,</span> <span class="n">secondGuid</span><span class="p">,</span> <span class="n">thirdGuid</span><span class="p">);</span>

    <span class="c1">//further logic</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">DateMethod</span><span class="p">(</span><span class="n">DateTime</span> <span class="n">dateTime</span><span class="p">,</span> <span class="n">DateTime</span> <span class="n">dateTime_2</span><span class="p">,</span> <span class="n">DateTime</span> <span class="n">dateTime_3</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Helpers</span><span class="p">.</span><span class="n">Guard</span><span class="p">.</span><span class="n">DateInThePast</span><span class="p">(</span><span class="n">dateTime</span><span class="p">,</span> <span class="n">dateTime_2</span><span class="p">,</span> <span class="n">dateTime_3</span><span class="p">);</span>

    <span class="c1">//further logic</span>
<span class="p">}</span>
</code></pre></div> <p>Because of the <em>params</em> keyword in the methods of the Guard class, it is possible to pass as much parameters to the method as needed.</p> <p>Obviously, it&#39;s also possible to use multiple checks in one method.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="k">void</span> <span class="nf">CombinedMethod</span><span class="p">(</span><span class="n">DateTime</span> <span class="n">dateTime_1</span><span class="p">,</span> <span class="n">DateTime</span> <span class="n">dateTime_2</span><span class="p">,</span> <span class="n">String</span> <span class="n">string_1</span><span class="p">,</span> <span class="n">String</span> <span class="n">string_2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Helpers</span><span class="p">.</span><span class="n">Guard</span><span class="p">.</span><span class="n">DateInThePast</span><span class="p">(</span><span class="n">dateTime_1</span><span class="p">,</span> <span class="n">dateTime_2</span><span class="p">);</span>
    <span class="n">Helpers</span><span class="p">.</span><span class="n">Guard</span><span class="p">.</span><span class="n">NotNullOrWhiteSpace</span><span class="p">(</span><span class="n">string_1</span><span class="p">,</span> <span class="n">string_2</span><span class="p">);</span>
    <span class="c1">//further logic</span>
<span class="p">}</span>
</code></pre></div> <p>As for the output, running the following <em>Run</em> method (I am aware of the awkward and rather bad naming, it&#39;s merely to make it obvious how the output will be generated) would throw an exception</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="k">void</span> <span class="nf">testMethod</span><span class="p">(</span><span class="n">StringBuilder</span> <span class="n">stringBuilder1</span><span class="p">,</span> <span class="n">StringBuilder</span> <span class="n">builder2</span><span class="p">,</span> <span class="n">StringBuilder</span> <span class="n">object3</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Helpers</span><span class="p">.</span><span class="n">Guard</span><span class="p">.</span><span class="n">NotNull</span><span class="p">(</span><span class="n">stringBuilder1</span><span class="p">,</span> <span class="n">builder2</span><span class="p">,</span> <span class="n">object3</span><span class="p">);</span>

    <span class="c1">//logic</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">Run</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">StringBuilder</span> <span class="n">builder1</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
    <span class="n">StringBuilder</span> <span class="n">builder2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
    <span class="n">StringBuilder</span> <span class="n">builder3</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="s">&quot;, world!&quot;</span><span class="p">);</span>

    <span class="n">testMethod</span><span class="p">(</span><span class="n">builder1</span><span class="p">,</span> <span class="n">builder2</span><span class="p">,</span> <span class="n">builder3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> <p>with this message. I&#39;ve split it into several lines for readability. The actual message is in one line:</p> <div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;NULL&gt;</span> has been passed: Class: Thuriot.Tests.GuardTest - Method: testMethod -
Args: stringBuilder1 = [NULL], builder2 = [Hello], object3 = [, world!]
</code></pre></div>]]></content:encoded> </item> <item> <title><![CDATA[Avoid Count() methods]]></title> <description><![CDATA[At work I&#39;m currently working with [dotTrace](http://www.jetbrains.com/profiler/) to check the performance of our application. A few of our issues were quickly traced back to the faulty usage of the Count() extension method. ]]></description> <link>http://localhost:4000/avoid-count-methods</link> <guid isPermaLink="true">http://localhost:4000/avoid-count-methods</guid> <pubDate>2011-08-22T18:50:00+00:00</pubDate> <content:encoded><![CDATA[<p>At work I&#39;m currently working with <a href="http://www.jetbrains.com/profiler/">dotTrace</a> to check the performance of our application. A few of our issues were quickly traced back to the faulty usage of the Count() extension method.</p> <p>Count() should be avoided as much as possible on IEnumerables. Count() is optimized to check for Count or Length properties, but if the used list doesn&#39;t have these implemented, Count() will iterate the entire list. We have a few fairly large lists in our application, so that quickly consumes quite a bit of time to run all the Count()&#39;s. Unless you&#39;re interested in the exact size of your list, I would say to avoid this method at all costs. However, even in this case there are a few better options.</p> <p>The most interesting option is to check with what kind of list you&#39;re working with. Lists like Collection, Array, List, ... either have a Length or Count property. This property is just a simple int that is already stored in the memory. It doesn&#39;t get much faster than this. The cost of calling these properties is neglectable. If the full size of your list is really important for your use case, it might pay off to switch to one of these types of lists.</p> <p>In case you&#39;re not interested in the full size of the list and don&#39;t want to or can&#39;t use a list that implements one of these properties, don&#39;t worry, there are a few other tips and tricks to handle these. I noticed that most of the time, Count() is used to check if there are any items in the list (<strong>Count() &gt; 0 , != 0 or == 0</strong> ). In this case it&#39;s much more interesting to use the LINQ Any() extension method. This method will check if there is one item in the list and return the result as a boolean. On a big list, you gain quite a bit of performance. Another common misusage of Count() is <strong>Where(...).Count() &gt; 0</strong>. In this case, it&#39;s far better to use <strong>Any(...)</strong>. In case 0 isn&#39;t the number you&#39;re checking against, it&#39;s still better to use <strong>Count(...)</strong>  instead and drop <strong>Where(...)</strong>. Since <strong>Where</strong> is lazy, it won&#39;t matter much for performance, but I find that the readability of what you are trying to do is increased greatly.</p> <p>For all the other cases, I wrote a few extension methods so it&#39;s possible to completely avoid using Count(). The idea behind these extension methods is that the list you&#39;re checking usually has a lot more items in it than the number you&#39;re checking against, for instance <strong>&gt; 2</strong> on a list of 300 items. On these kinds of checks, my extension methods truly shine. Rather than counting the whole list, they count x+1 items from the list, where x is the number you&#39;re checking against. You don&#39;t need to do any more counting than x+1 as you can check any of the conditions with this amount. This way, the actual counting is reduced greatly. When used correctly, the average cost will be a lot lower than using <strong>Count()</strong>. All of the extension methods also have an overload to allow you to specify a <strong>Where(...)</strong> clause so it can do everything in one go, rather than having to do a <strong>Where(...)</strong> first and a <strong>Count()</strong> after.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;comparePredicate&quot;&gt;The comparison function.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;The result of the passed predicate.&lt;/returns&gt;</span>
<span class="k">private</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">OptimizedCount</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">comparePredicate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enumerable</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">numberOfItems</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">wherePredicate</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">enumerable</span> <span class="p">=</span> <span class="n">enumerable</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">wherePredicate</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">var</span> <span class="n">numberOfItemsToCount</span> <span class="p">=</span> <span class="k">checked</span><span class="p">(</span><span class="n">numberOfItems</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">countedItems</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">enumerator</span> <span class="p">=</span> <span class="n">enumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">enumerator</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">()</span> <span class="p">&amp;</span><span class="n">amp</span><span class="p">;&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">countedItems</span> <span class="p">&lt;</span> <span class="n">numberOfItemsToCount</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">countedItems</span><span class="p">++;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">returnValue</span> <span class="p">=</span> <span class="n">comparePredicate</span><span class="p">(</span><span class="n">countedItems</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">returnValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">CountEqualTo</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate to apply to the list.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">OptimizedCount</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">wherePredicate</span><span class="p">,</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">==</span> <span class="n">numberOfItems</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains less items than defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="na">[SuppressMessage(&quot;Microsoft.Naming&quot;, &quot;CA1702:CompoundWordsShouldBeCasedCorrectly&quot;, MessageId = &quot;CountLess&quot;)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountLessThan</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">CountLessThan</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate to apply to the list.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains less items than defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="na">[SuppressMessage(&quot;Microsoft.Naming&quot;, &quot;CA1702:CompoundWordsShouldBeCasedCorrectly&quot;, MessageId = &quot;CountLess&quot;)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountLessThan</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">OptimizedCount</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">wherePredicate</span><span class="p">,</span>  <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">numberOfItems</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains more items than defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountGreaterThan</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">CountGreaterThan</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate to apply to the list.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains more items than defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountGreaterThan</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">OptimizedCount</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">wherePredicate</span><span class="p">,</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">&gt;</span> <span class="n">numberOfItems</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains less or the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="na">[SuppressMessage(&quot;Microsoft.Naming&quot;, &quot;CA1702:CompoundWordsShouldBeCasedCorrectly&quot;, MessageId = &quot;CountLess&quot;)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountLessOrEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">CountLessOrEqualTo</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate to apply to the list.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains less or the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="na">[SuppressMessage(&quot;Microsoft.Naming&quot;, &quot;CA1702:CompoundWordsShouldBeCasedCorrectly&quot;, MessageId = &quot;CountLess&quot;)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountLessOrEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">OptimizedCount</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">wherePredicate</span><span class="p">,</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">&lt;=</span> <span class="n">numberOfItems</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains more or the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountGreaterOrEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">CountGreaterOrEqualTo</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///&lt;summary&gt;</span>
<span class="c1">/// Counts a list, keeping in mind the check you are planning to do on it.</span>
<span class="c1">/// This way you don&#39;t have to count every item when you don&#39;t need to, resulting in less overhead.</span>
<span class="c1">///&lt;/summary&gt;</span>
<span class="c1">///&lt;param name=&quot;enumerable&quot;&gt;The list with items getting counted.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;numberOfItems&quot;&gt;The number of items that you are going to check for. The same number should be used in the predicate.&lt;/param&gt;</span>
<span class="c1">///&lt;param name=&quot;wherePredicate&quot;&gt;The filter predicate to apply to the list.&lt;/param&gt;</span>
<span class="c1">///&lt;typeparam name=&quot;T&quot;&gt;The type of item getting counted. This is of no relevance, just to keep the method generic.&lt;/typeparam&gt;</span>
<span class="c1">///&lt;exception cref=&quot;OverflowException&quot;&gt;An overflow exception will be thrown when &#39;numberOfItems&#39; equals int.MaxValue&lt;/exception&gt;</span>
<span class="c1">///&lt;returns&gt;True if the list contains more or the same amount of items as defined in &#39;numberOfItems&#39;.&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">CountGreaterOrEqualTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">enumerable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">wherePredicate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">OptimizedCount</span><span class="p">(</span><span class="n">enumerable</span><span class="p">,</span> <span class="n">numberOfItems</span><span class="p">,</span> <span class="n">wherePredicate</span><span class="p">,</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">&gt;=</span> <span class="n">numberOfItems</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> <p>A few more tips and tricks regarding <strong>Count()</strong>&#39;s. Do not use them in the check condition of for-loops. It will be executed every loop, causing a severe performance issue.</p> <p>Another, in my opinion, interesting optimization is the following one:</p> <p>Original code where the sublist is a Collection:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">number</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">SelectMany</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">SubList</span><span class="p">).</span><span class="n">Count</span><span class="p">();</span>
</code></pre></div> <p>Optimized code:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">number</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">SubList</span><span class="p">.</span><span class="n">Count</span><span class="p">);</span>
</code></pre></div> <p>This way it will only make the sum of a few integers, which is much faster than creating one big list in memory, then count all the items.</p> ]]></content:encoded> </item> </channel> </rss>