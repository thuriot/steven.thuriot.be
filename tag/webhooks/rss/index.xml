<?xml version="1.0" encoding="UTF-8"?> <rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"> <channel> <title><![CDATA[Steven Thuriot.be &mdash; Webhooks]]></title> <description><![CDATA[Thoughts, stories and ideas.]]></description> <link>http://steven.thuriot.be</link> <link href="//steven.thuriot.be/tag/webhooks/rss/" rel="self" type="application/rss+xml"/> <ttl>60</ttl> <item> <title><![CDATA[Secure Webhooks]]></title> <description><![CDATA[Security is always a tricky one. Especially when it comes to webhooks, it can be difficult to make sure that the payload being received is a valid one. For some API&#39;s, a service-to-service token can easily be set up, but when dealing with public api&#39;s, it&#39;s not always that simple. Dealing with this issue, I had a quick glance at how GitHub solves this issue and it&#39;s quite ingenious. They basically compute a Hash-based Message Authentication Code (HMAC) by using the SHA256 hash function for each payload they&#39;re sending, using a common secret. To validate the payload, you just calculate the same HMAC using your common secret. If it matches, the payload is valid! If not, ignore and return an error code from your api. Doing this is actually pretty simple. First, let&#39;s send out our own payload from our API: ```csharp //GitHub&#39;s signature name, feel free to use your own! const string HookSignatureHeader=&quot;X-Hub-Signature-256&quot;; string payload=SerializeToJson(body); byte[] payloadBytes=Encoding.UTF8.GetBytes(payload); var headerValue=CreateHeaderValue(secret, payloadBytes); var content=new StringContent(payload, Encoding.UTF8, &quot;application/json&quot;); content.Headers.Add(HookSignatureHeader, headerValue); ``` Additionally, just as usefull is to add some metadata in the headers: ```csharp content.Headers.Add(&quot;X-Hook-Event&quot;, &quot;MyWebHookEventType&quot;); ``` This way, the consumers of your API can just skip the validation/deserialization/... of your payload when they&#39;re not interested in that specific event. Validation would work in a very similar way: ```csharp //Optionally check &quot;X-Hook-Event&quot; header for starters to see if we&#39;re even interested in this event at all. if (!Request.Headers.TryGetValue(headerName, out var values)) { return Unauthorized(); } var signature=values.ToString(); //Prefixing makes for an additional cheap check const string SignaturePrefix=&quot;sha256=&quot;; if (signature?.StartsWith(SignaturePrefix, StringComparison.OrdinalIgnoreCase) != true) { return Unauthorized(); } using var ms=new MemoryStream(); await Request.Body.CopyToAsync(ms); //Or BodyReader if you&#39;re not in netstandard / Abstractions. var payload=ms.ToArray(); var validationSignature=CreateHeaderValue(secret, payload); if (!StringComparer.OrdinalIgnoreCase.Equals(signature, validationSignature)) { return Unauthorized(); } //Payload is valid, deserialize and handle... var body=Encoding.UTF8.GetString(payload); var payloadEntity=DeserializeFromJson(body); ``` Since we already read the full body stream here, you don&#39;t have to declare a `[FromBody]` attribute on your API to avoid the payload being deserialized early. Not only can you not validate the deserialized payload (your serializer settings might differ resulting in a different HMAC), this provides some additional performance optimization since invalid payloads and irrelevant headers won&#39;t be deserialized or read at all! Calculating the actual header is only a few lines in newer .NET versions: ```csharp private static string CalculateSignature(string secret, byte[] payloadBytes) { byte[] secretBytes=Encoding.ASCII.GetBytes(secret); using var sha=new HMACSHA256(secretBytes); byte[] hash=sha.ComputeHash(payloadBytes); return SignaturePrefix + Convert.ToHexString(hash); } ``` Or In case you&#39;re writing this in netstandard, which doesn&#39;t have the `Convert.ToHexString` call yet: ```csharp private static string CalculateSignature(string secret, byte[] payloadBytes) { byte[] secretBytes=Encoding.ASCII.GetBytes(secret); using var sha=new HMACSHA256(secretBytes); byte[] hash=sha.ComputeHash(payloadBytes); var builder=new StringBuilder((hash.Length * 2) + SignaturePrefix.Length); builder.Append(SignaturePrefix); for (int i=0; i &lt; hash.Length; i++) { builder.AppendFormat(&quot;{0:X2}&quot;, hash[i]); } return builder.ToString(); } ``` A sample GitHub repo for this can be found [here](https://github.com/StevenThuriot/SecureWebhooks). Happy validating! ]]></description> <link>//steven.thuriot.be/secure-webhooks</link> <guid isPermaLink="true">//steven.thuriot.be/secure-webhooks</guid> <pubDate>2022-01-24T19:12:00+00:00</pubDate> <media:content url="//cdn.thuriot.be/images/Covers/hash.jpg" medium="image"/> <content:encoded><![CDATA[<p>Security is always a tricky one. Especially when it comes to webhooks, it can be difficult to make sure that the payload being received is a valid one. For some API&#39;s, a service-to-service token can easily be set up, but when dealing with public api&#39;s, it&#39;s not always that simple.</p> <p>Dealing with this issue, I had a quick glance at how GitHub solves this issue and it&#39;s quite ingenious. They basically compute a Hash-based Message Authentication Code (HMAC) by using the SHA256 hash function for each payload they&#39;re sending, using a common secret. To validate the payload, you just calculate the same HMAC using your common secret. If it matches, the payload is valid! If not, ignore and return an error code from your api.</p> <p>Doing this is actually pretty simple. First, let&#39;s send out our own payload from our API:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="c1">//GitHub&#39;s signature name, feel free to use your own!</span>
<span class="k">const</span> <span class="kt">string</span> <span class="n">HookSignatureHeader</span> <span class="p">=</span> <span class="s">&quot;X-Hub-Signature-256&quot;</span><span class="p">;</span>

<span class="kt">string</span> <span class="n">payload</span> <span class="p">=</span> <span class="n">SerializeToJson</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>
<span class="kt">byte</span><span class="p">[]</span> <span class="n">payloadBytes</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">headerValue</span> <span class="p">=</span> <span class="n">CreateHeaderValue</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">payloadBytes</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">content</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringContent</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">,</span> <span class="s">&quot;application/json&quot;</span><span class="p">);</span>
<span class="n">content</span><span class="p">.</span><span class="n">Headers</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">HookSignatureHeader</span><span class="p">,</span> <span class="n">headerValue</span><span class="p">);</span>
</code></pre></div> <p>Additionally, just as usefull is to add some metadata in the headers:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">content</span><span class="p">.</span><span class="n">Headers</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;X-Hook-Event&quot;</span><span class="p">,</span> <span class="s">&quot;MyWebHookEventType&quot;</span><span class="p">);</span>
</code></pre></div> <p>This way, the consumers of your API can just skip the validation/deserialization/... of your payload when they&#39;re not interested in that specific event.</p> <p>Validation would work in a very similar way:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="c1">//Optionally check &quot;X-Hook-Event&quot; header for starters to see if we&#39;re even interested in this event at all.</span>

<span class="k">if</span> <span class="p">(!</span><span class="n">Request</span><span class="p">.</span><span class="n">Headers</span><span class="p">.</span><span class="n">TryGetValue</span><span class="p">(</span><span class="n">headerName</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">values</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">Unauthorized</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">signature</span> <span class="p">=</span> <span class="n">values</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>

<span class="c1">//Prefixing makes for an additional cheap check</span>
<span class="k">const</span> <span class="kt">string</span> <span class="n">SignaturePrefix</span> <span class="p">=</span> <span class="s">&quot;sha256=&quot;</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">signature</span><span class="p">?.</span><span class="n">StartsWith</span><span class="p">(</span><span class="n">SignaturePrefix</span><span class="p">,</span> <span class="n">StringComparison</span><span class="p">.</span><span class="n">OrdinalIgnoreCase</span><span class="p">)</span> <span class="p">!=</span> <span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">Unauthorized</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">using</span> <span class="nn">var</span> <span class="n">ms</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MemoryStream</span><span class="p">();</span>
<span class="k">await</span> <span class="n">Request</span><span class="p">.</span><span class="n">Body</span><span class="p">.</span><span class="n">CopyToAsync</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span> <span class="c1">//Or BodyReader if you&#39;re not in netstandard / Abstractions.</span>

<span class="kt">var</span> <span class="n">payload</span> <span class="p">=</span> <span class="n">ms</span><span class="p">.</span><span class="n">ToArray</span><span class="p">();</span>

<span class="kt">var</span> <span class="n">validationSignature</span> <span class="p">=</span> <span class="n">CreateHeaderValue</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(!</span><span class="n">StringComparer</span><span class="p">.</span><span class="n">OrdinalIgnoreCase</span><span class="p">.</span><span class="n">Equals</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">validationSignature</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">Unauthorized</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//Payload is valid, deserialize and handle...</span>
<span class="kt">var</span> <span class="n">body</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetString</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">payloadEntity</span> <span class="p">=</span> <span class="n">DeserializeFromJson</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>
</code></pre></div> <p>Since we already read the full body stream here, you don&#39;t have to declare a <code>[FromBody]</code> attribute on your API to avoid the payload being deserialized early. Not only can you not validate the deserialized payload (your serializer settings might differ resulting in a different HMAC), this provides some additional performance optimization since invalid payloads and irrelevant headers won&#39;t be deserialized or read at all!</p> <p>Calculating the actual header is only a few lines in newer .NET versions:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">CalculateSignature</span><span class="p">(</span><span class="kt">string</span> <span class="n">secret</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span> <span class="n">payloadBytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">byte</span><span class="p">[]</span> <span class="n">secretBytes</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">ASCII</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="n">secret</span><span class="p">);</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">sha</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HMACSHA256</span><span class="p">(</span><span class="n">secretBytes</span><span class="p">);</span>

    <span class="kt">byte</span><span class="p">[]</span> <span class="n">hash</span> <span class="p">=</span> <span class="n">sha</span><span class="p">.</span><span class="n">ComputeHash</span><span class="p">(</span><span class="n">payloadBytes</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">SignaturePrefix</span> <span class="p">+</span> <span class="n">Convert</span><span class="p">.</span><span class="n">ToHexString</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> <p>Or In case you&#39;re writing this in netstandard, which doesn&#39;t have the <code>Convert.ToHexString</code> call yet:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">CalculateSignature</span><span class="p">(</span><span class="kt">string</span> <span class="n">secret</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span> <span class="n">payloadBytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">byte</span><span class="p">[]</span> <span class="n">secretBytes</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">ASCII</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="n">secret</span><span class="p">);</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">sha</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HMACSHA256</span><span class="p">(</span><span class="n">secretBytes</span><span class="p">);</span>

    <span class="kt">byte</span><span class="p">[]</span> <span class="n">hash</span> <span class="p">=</span> <span class="n">sha</span><span class="p">.</span><span class="n">ComputeHash</span><span class="p">(</span><span class="n">payloadBytes</span><span class="p">);</span>

    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">((</span><span class="n">hash</span><span class="p">.</span><span class="n">Length</span> <span class="p">*</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="n">SignaturePrefix</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>

    <span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">SignaturePrefix</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">hash</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">builder</span><span class="p">.</span><span class="n">AppendFormat</span><span class="p">(</span><span class="s">&quot;{0:X2}&quot;</span><span class="p">,</span> <span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">builder</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div> <p>A sample GitHub repo for this can be found <a href="https://github.com/StevenThuriot/SecureWebhooks">here</a>. Happy validating!</p> ]]></content:encoded> </item> </channel> </rss>