<?xml version="1.0" encoding="UTF-8"?> <rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"> <channel> <title><![CDATA[Steven Thuriot.be &mdash; NuGet]]></title> <description><![CDATA[Thoughts, stories and ideas.]]></description> <link>http://steven.thuriot.be</link> <link href="http://steven.thuriot.be/tag/nuget/rss/" rel="self" type="application/rss+xml"/> <ttl>60</ttl> <item> <title><![CDATA[Nuget Build And Deploy]]></title> <description><![CDATA[After attending [Scott Hanselman](http://www.hanselman.com)&#39;s [session at Techdays](http://channel9.msdn.com/Events/TechDays/TechDays-2011-Belgium/KEY01), I was really excited about [NuGet](http://nuget.org/). It&#39;s so easy to use and so versatile. Only one thing bothered me, and that is actually building your own NuGet package. First you need to let it generate a nuspec file, fill in everything by hand and only then you can let it generate your NuGet package. Then you need to update said NuSpec file everything something of relevance changes.  It&#39;s not a hard thing to do, it&#39;s just a bit bothersome and we&#39;d be off better if this was automated to some point. ]]></description> <link>http://steven.thuriot.be/nuget-build-and-deploy</link> <guid isPermaLink="true">http://steven.thuriot.be/nuget-build-and-deploy</guid> <pubDate>2012-03-05T18:41:00+00:00</pubDate> <content:encoded><![CDATA[<p>After attending <a href="http://www.hanselman.com">Scott Hanselman</a>&#39;s <a href="http://channel9.msdn.com/Events/TechDays/TechDays-2011-Belgium/KEY01">session at Techdays</a>, I was really excited about <a href="http://nuget.org/">NuGet</a>. It&#39;s so easy to use and so versatile. Only one thing bothered me, and that is actually building your own NuGet package. First you need to let it generate a nuspec file, fill in everything by hand and only then you can let it generate your NuGet package. Then you need to update said NuSpec file everything something of relevance changes.  It&#39;s not a hard thing to do, it&#39;s just a bit bothersome and we&#39;d be off better if this was automated to some point.</p> <p>So I started working on a little tool to help me build my NuSpec on the fly and create a NuGet package right away and potentially use this as a Visual Studio&#39;s build event.</p> <p>The post build event can be implemented like this:</p> <div class="highlight"><pre><code class="language-xml" data-lang="xml">if &quot;$(ConfigurationName)&quot; == &quot;Release&quot; (  
  del /Q /F *.tmp
  &quot;R:\PathToTheExecutable\NuGet.BuildAndDeploy.exe&quot; /dll &quot;lib\$(TargetFileName)&quot; /outputdir &quot;$(TargetDir)\..&quot; /projectUrl http://thuriot.be/ /tags Small helper framework /dependencies &quot;Ninject 2.2&quot;
)
</code></pre></div> <p>The build output then looks like this:</p> <div class="highlight"><pre><code class="language-xml" data-lang="xml">------ Rebuild All started: Project: Aikido, Configuration: Release Any CPU ------
  Aikido -<span class="ni">&amp;gt;</span> E:\Projects\Aikido\Release\lib\Aikido.dll
  Generating the NuSpec file for Aikido Framework version 1.0.0.0.

  Finished generating the NuSpec file succesfully.
  Writing NuSpec file... NuSpec file saved succesfully.

  Starting to build the NuGet pack...

  Attempting to build package from &#39;Aikido_Framework.nuspec&#39;.
  Successfully created package &#39;E:\Projects\- NuGet Packages\NuGet Packages\Aikido_Framework.1.0.0.0.nupkg&#39;.

------ Skipped Rebuild All: Project: Aikido.Test, Configuration: Release Any CPU ------
Project not selected to build for this solution configuration 
========== Rebuild All: 1 succeeded, 0 failed, 1 skipped ==========
</code></pre></div> <p>The generated NuSpec file looks like this:</p> <div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;package</span> <span class="na">xmlns=</span><span class="s">&quot;http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;metadata&gt;</span>
    <span class="nt">&lt;id&gt;</span>Aikido<span class="nt">&lt;/id&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.0.0.0<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;authors&gt;</span>Steven Thuriot<span class="nt">&lt;/authors&gt;</span>
    <span class="nt">&lt;owners&gt;</span>Steven Thuriot<span class="nt">&lt;/owners&gt;</span>
    <span class="nt">&lt;projectUrl&gt;</span>http://thuriot.be/<span class="nt">&lt;/projectUrl&gt;</span>
    <span class="nt">&lt;requireLicenseAcceptance&gt;</span>false<span class="nt">&lt;/requireLicenseAcceptance&gt;</span>
    <span class="nt">&lt;description&gt;</span>Small helper framework<span class="nt">&lt;/description&gt;</span>
    <span class="nt">&lt;tags&gt;</span>Small helper framework<span class="nt">&lt;/tags&gt;</span>
    <span class="nt">&lt;dependencies&gt;</span>
      <span class="nt">&lt;dependency</span> <span class="na">id=</span><span class="s">&quot;Ninject&quot;</span> <span class="na">version=</span><span class="s">&quot;2.2&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>
  <span class="nt">&lt;/metadata&gt;</span>
<span class="nt">&lt;/package&gt;</span>
</code></pre></div> <p>I realise it&#39;s a quick and dirty solution, but for a tool this small and simple it really doesn&#39;t matter, nor is it worth spending a lot more time on it. It took a minimal amount of work to make, it does what it is supposed to do and that is more than enough for its purpose.</p> <p><img src="//cdn.thuriot.be/GithubIcon.png" alt="GitHub"> You can take a look at the source code or download a built assembly on <a href="https://github.com/StevenThuriot/NuGet-Build-And-Deploy">GitHub</a>.</p> <p>Enjoy!</p> ]]></content:encoded> </item> <item> <title><![CDATA[NuGet Guidance]]></title> <description><![CDATA[Sometimes a NuGet package can contain complex install logic. When this is the case, it can be a real hassle for a C# programmer to write all the code in powershell. ]]></description> <link>http://steven.thuriot.be/nuget-guidance</link> <guid isPermaLink="true">http://steven.thuriot.be/nuget-guidance</guid> <pubDate>2012-04-07T17:22:00+00:00</pubDate> <content:encoded><![CDATA[<p>Sometimes a NuGet package can contain complex install logic. When this is the case, it can be a real hassle for a C# programmer to write all the code in powershell. </p> <p>This project is a hoster for any &quot;recipe&quot; you include in your nuget package. Using MEF, the recipes will run inside this hoster project.</p> <p>For your convenience, all you have to do is inherit BaseRecipe when creating new recipes.</p> <p>Sample usage:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">using</span> <span class="nn">NuGetGuidance.Domain</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.IO</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Recipe</span> <span class="p">:</span> <span class="n">BaseRecipe</span> 
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Execute</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">Prompt</span><span class="p">(</span><span class="s">&quot;Server URI&quot;</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span>
        <span class="n">Log</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&quot;Received input: {0}&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

        <span class="kt">var</span> <span class="n">project</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">ReadAllText</span><span class="p">(</span><span class="n">Project</span><span class="p">.</span><span class="n">FullName</span><span class="p">);</span>

        <span class="c1">//Do stuff  </span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>]]></content:encoded> </item> <item> <title><![CDATA[NuGet and Hoster Packages in a CI environment]]></title> <description><![CDATA[#What is NuGet? [NuGet](http://www.nuget.org/) is the package manager for the Microsoft development platform including .NET. The NuGet client tools provide the ability to produce and consume packages. ]]></description> <link>http://steven.thuriot.be/nuget-and-hoster-packages-in-a-ci-environment</link> <guid isPermaLink="true">http://steven.thuriot.be/nuget-and-hoster-packages-in-a-ci-environment</guid> <pubDate>2013-10-16T18:32:00+00:00</pubDate> <content:encoded><![CDATA[<h1>What is NuGet?</h1> <p><a href="http://www.nuget.org/">NuGet</a> is the package manager for the Microsoft development platform including .NET. The NuGet client tools provide the ability to produce and consume packages. </p> <p>The NuGet Gallery is the central package repository used by all package authors and consumers.</p> <h1>Restoring Packages on Build</h1> <p>NuGet has come a long way since it was first introduced and has gained a lot of popularity in our community. More and more parties are starting to ship their assemblies as NuGet packages and they&#39;re so easy to use that there really isn&#39;t any reason not to.</p> <p>Building the packages themselves used to be a small pain to set up, but even that is implemented into NuGet that it&#39;s just a parameter away. By enabling the NuGet package restore feature, a few files are added to the solution.</p> <p><a href="//cdn.thuriot.be/NuGetCI/packagerestore.png"><img src="//cdn.thuriot.be/NuGetCI/packagerestore.png" alt="Package Restore"></a></p> <p>One of these files is an msbuild targets file. It generally contains data that (as most of you know) allows the user to restore packages as a pre-build action. This way, the actual packages don&#39;t have to be checked into version control.</p> <p><a href="//cdn.thuriot.be/NuGetCI/targets.png"><img src="//cdn.thuriot.be/NuGetCI/targets.png" alt="Targets"></a></p> <p><em>As of <a href="https://docs.nuget.org/docs/reference/package-restore#MSBuild-Integrated_Package_Restore">version 2.7+</a> of NuGet, this approach is no longer needed if you just want to restore the packages. The option is still available, though, in case you require more specific settings. For more information about the automatic package restore in v2.7+ and how to possibly migrate your solution, you can visit the nuget docs <a href="http://docs.nuget.org/docs/workflows/migrating-to-automatic-package-restore">here</a>.</em></p> <h1>Building Packages</h1> <p>Another neat feature implemented in this file, however, is something that can be triggered using the &quot;BuildPackage&quot; parameter, which can be passed to msbuild. When setting this parameter to &quot;true&quot;, NuGet packages will be automatically build as a post-build event. NuGet will automatically retrieve all metadata from the project and generate a fitting nuspec file, rending <a href="http://steven.thuriot.be/projects/nuget-build-and-deploy/" title="NuGet build and deploy" target="_blank">one of my previous projects</a> completely useless. In case this generated nuspec isn&#39;t sufficient, you can create a custom nuspec in the root folder of the project. If this file has the same name as your csproj, NuGet will automatically merge the metadata it retrieves from the project with the nuspec file you placed there. Magic!</p> <p>Long story short, setting up automatic NuGet package creation in a CI environment is peanuts. </p> <p>At this point, you might be thinking <em>&quot;Alright, Steven, what exactly are we trying to do here? We&#39;re just scratching some basic nuget stuff here...&quot;</em>. </p> <p>Hold your horses, here comes the tricky part. What if you’re going a step further than that? One of my current projects contains a hoster application. The idea was to allow the user of my framework to easily create a module with all their specific logic, without having to worry to much about that specific window, WPF and framework logic that gets rewritten every time you work on a similar project. This module can be seen as a simple MEF plugin that the hoster will pick up. The hoster itself will take care of all the visuals, navigation through these modules and much more. </p> <h1>Hoster as a package</h1> <p>Because all of the separate parts can easily be managed as NuGet dependencies, it would be very useful if the actual hoster executable was distributed as a NuGet as well. Starting NuGet v2.3, the packages support including custom targets and props files. Writing one to copy the hoster to the output folder would then be peanuts.</p> <div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="err">&lt;</span> ?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
<span class="nt">&lt;project</span> <span class="na">ToolsVersion=</span><span class="s">&quot;4.0&quot;</span> <span class="na">xmlns=</span><span class="s">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;propertygroup&gt;</span>
        <span class="nt">&lt;startaction&gt;</span>Program<span class="nt">&lt;/startaction&gt;</span>
        <span class="nt">&lt;startprogram&gt;</span>$(TargetDir)Nova.Shell.exe<span class="nt">&lt;/startprogram&gt;</span>

        <span class="nt">&lt;builddependson&gt;</span>
            $(BuildDependsOn);
            CopyNovaShell;
        <span class="nt">&lt;/builddependson&gt;</span>
    <span class="nt">&lt;/propertygroup&gt;</span>

    <span class="nt">&lt;target</span> <span class="na">Name=</span><span class="s">&quot;CopyNovaShell&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;copy</span> <span class="na">SourceFiles=</span><span class="s">&quot;$(MSBuildThisFileDirectory)\..\..\tools\net45\Nova.Shell.exe&quot;</span> <span class="na">DestinationFolder=</span><span class="s">&quot;$(TargetDir)&quot;</span><span class="nt">&gt;&lt;/copy&gt;</span>
    <span class="nt">&lt;/target&gt;</span>

<span class="nt">&lt;/project&gt;</span>
</code></pre></div> <p>The above targets file will automatically copy my hoster executable, included in the NuGet package, to the output folder as a post-build event. With this set up, I set up my CI builds and turned on the &quot;BuildPackage&quot; feature. Everything was working out well, except for the hoster package. NuGet was automatically adding the hoster exe to the lib folder in the NuGet package. Because of this, referencing the NuGet would reference the hoster in my module project, and that was exactly something I did not want!</p> <p>As a fix for this issue, I wrote my own custom targets file that picks up in the NuGet build chain and imported it in my hoster project.</p> <div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="err">&lt;</span> ?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
<span class="nt">&lt;project</span> <span class="na">ToolsVersion=</span><span class="s">&quot;4.0&quot;</span> <span class="na">xmlns=</span><span class="s">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;propertygroup</span> <span class="na">Condition=</span><span class="s">&quot;$(BuildPackage) == &#39;true&#39;&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;previousbuildcommand&gt;</span>$(BuildCommand)<span class="nt">&lt;/previousbuildcommand&gt;</span>
                <span class="nt">&lt;buildcommand&gt;</span>echo Starting custom nuget pack<span class="nt">&lt;/buildcommand&gt;</span>

        <span class="nt">&lt;builddependson&gt;</span>
            $(BuildDependsOn);
            PackageNuGet;
        <span class="nt">&lt;/builddependson&gt;</span>
    <span class="nt">&lt;/propertygroup&gt;</span>

    <span class="nt">&lt;target</span> <span class="na">Name=</span><span class="s">&quot;PackageNuGet&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;getproductversion</span> <span class="na">AssemblyFileName=</span><span class="s">&quot;$(TargetDir)Nova.Shell.exe&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;output</span> <span class="na">PropertyName=</span><span class="s">&quot;AssemblyInfoVersion&quot;</span> <span class="na">TaskParameter=</span><span class="s">&quot;ProductVersion&quot;</span><span class="nt">&gt;&lt;/output&gt;</span>
                <span class="nt">&lt;/getproductversion&gt;</span>

        <span class="nt">&lt;exec</span> <span class="na">Command=</span><span class="s">&quot;$(NuGetCommand) pack &amp;quot;$(ProjectDir)NuGet\Nova.Shell.nuspec&amp;quot; -p OutputPath=&amp;quot;$(TargetDir);version=$(AssemblyInfoVersion)&amp;quot; -o &amp;quot;$(PackageOutputDir)&amp;quot; -symbols &quot;</span><span class="nt">&gt;&lt;/exec&gt;</span>

                <span class="nt">&lt;createproperty</span> <span class="na">Value=</span><span class="s">&quot;$(PreviousBuildCommand)&quot;</span><span class="nt">&gt;</span>
                        <span class="nt">&lt;output</span> <span class="na">PropertyName=</span><span class="s">&quot;BuildCommand&quot;</span> <span class="na">TaskParameter=</span><span class="s">&quot;Value&quot;</span><span class="nt">&gt;&lt;/output&gt;</span>
                <span class="nt">&lt;/createproperty&gt;</span>
    <span class="nt">&lt;/target&gt;</span>

        <span class="nt">&lt;usingtask</span> <span class="na">TaskName=</span><span class="s">&quot;GetProductVersion&quot;</span> <span class="na">TaskFactory=</span><span class="s">&quot;CodeTaskFactory&quot;</span> <span class="na">AssemblyFile=</span><span class="s">&quot;$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;parametergroup&gt;</span>
            <span class="nt">&lt;assemblyfilename</span> <span class="na">ParameterType=</span><span class="s">&quot;System.String&quot;</span> <span class="na">Required=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;&lt;/assemblyfilename&gt;</span>
            <span class="nt">&lt;productversion</span> <span class="na">ParameterType=</span><span class="s">&quot;System.String&quot;</span> <span class="na">Output=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;&lt;/productversion&gt;</span>
        <span class="nt">&lt;/parametergroup&gt;</span>

        <span class="nt">&lt;task&gt;</span>
            <span class="nt">&lt;reference</span> <span class="na">Include=</span><span class="s">&quot;System.Core&quot;</span><span class="nt">&gt;&lt;/reference&gt;</span>
            <span class="nt">&lt;using</span> <span class="na">Namespace=</span><span class="s">&quot;System&quot;</span><span class="nt">&gt;&lt;/using&gt;</span>
            <span class="nt">&lt;using</span> <span class="na">Namespace=</span><span class="s">&quot;System.Diagnostics&quot;</span><span class="nt">&gt;&lt;/using&gt;</span>
            <span class="nt">&lt;using</span> <span class="na">Namespace=</span><span class="s">&quot;System.IO&quot;</span><span class="nt">&gt;&lt;/using&gt;</span>
            <span class="nt">&lt;using</span> <span class="na">Namespace=</span><span class="s">&quot;System.Net&quot;</span><span class="nt">&gt;&lt;/using&gt;</span>
            <span class="nt">&lt;using</span> <span class="na">Namespace=</span><span class="s">&quot;Microsoft.Build.Framework&quot;</span><span class="nt">&gt;&lt;/using&gt;</span>
            <span class="nt">&lt;using</span> <span class="na">Namespace=</span><span class="s">&quot;Microsoft.Build.Utilities&quot;</span><span class="nt">&gt;&lt;/using&gt;</span>
            <span class="nt">&lt;code</span> <span class="na">Type=</span><span class="s">&quot;Fragment&quot;</span> <span class="na">Language=</span><span class="s">&quot;cs&quot;</span><span class="nt">&gt;</span>
                <span class="err">&lt;</span> ![CDATA[
                                this.ProductVersion = FileVersionInfo.GetVersionInfo(this.AssemblyFileName).ProductVersion;
            ]]&gt;
            <span class="nt">&lt;/code&gt;</span>
        <span class="nt">&lt;/task&gt;</span>
    <span class="nt">&lt;/usingtask&gt;</span>
<span class="nt">&lt;/project&gt;</span>
</code></pre></div> <p>The above script will temporarily overwrite the NuGet build command and replace it with a custom one. The custom build command will read out the Assembly Informational version attribute of the package you&#39;re trying to build and use it to build and version the Nuget package we desire. The actual nuspec I used as a template looks like this:</p> <div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="err">&lt;</span> ?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
<span class="nt">&lt;package</span> <span class="na">xmlns=</span><span class="s">&quot;http://schemas.microsoft.com/packaging/2013/01/nuspec.xsd&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;metadata</span> <span class="na">minClientVersion=</span><span class="s">&quot;2.3&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;id&gt;</span>Nova.Shell<span class="nt">&lt;/id&gt;</span>
        <span class="nt">&lt;version&gt;</span>$version$<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;title&gt;</span>Nova Shell<span class="nt">&lt;/title&gt;</span>
        <span class="nt">&lt;authors&gt;</span>Steven Thuriot<span class="nt">&lt;/authors&gt;</span>
        <span class="nt">&lt;owners&gt;</span>Steven Thuriot<span class="nt">&lt;/owners&gt;</span>
        <span class="nt">&lt;licenseurl&gt;</span>https://github.com/StevenThuriot/Nova/blob/master/LICENSE.md<span class="nt">&lt;/licenseurl&gt;</span>
        <span class="nt">&lt;projecturl&gt;</span>http://github.com/StevenThuriot/Nova<span class="nt">&lt;/projecturl&gt;</span>
        <span class="nt">&lt;requirelicenseacceptance&gt;</span>true<span class="nt">&lt;/requirelicenseacceptance&gt;</span>
        <span class="nt">&lt;description&gt;</span>Small graphical framework to quickly start developing your apps without having to worry too much about controls and looks.<span class="nt">&lt;/description&gt;</span>
    <span class="nt">&lt;/metadata&gt;</span>
    <span class="nt">&lt;files&gt;</span>
        <span class="nt">&lt;file</span> <span class="na">src=</span><span class="s">&quot;Nova.Shell.targets&quot;</span> <span class="na">target=</span><span class="s">&quot;build\net45\Nova.Shell.targets&quot;</span><span class="nt">&gt;&lt;/file&gt;</span>
        <span class="nt">&lt;file</span> <span class="na">src=</span><span class="s">&quot;$OutputPath$Nova.Shell.exe&quot;</span> <span class="na">target=</span><span class="s">&quot;tools\net45\&quot;</span><span class="nt">&gt;&lt;/file&gt;</span>
    <span class="nt">&lt;/files&gt;</span>
<span class="nt">&lt;/package&gt;</span>
</code></pre></div> <p>The result of all of this work, is a NuGet package without a lib folder, that contains our hoster executable in its tools folder. Combined with an internal targets file, the hoster gets copied to the output directory and used as the start-up parameter when starting the csproj with Visual Studio.</p> <p>Combine all of this with the automated builds and we have set up an easy and automatic way to create and push our NuGet hoster package.</p> ]]></content:encoded> </item> <item> <title><![CDATA[NuGet as a plugin deployment platform]]></title> <description><![CDATA[[NuGet](http://www.nuget.org/) has become quite popular among .NET developers. As described in one of my earlier posts, it is an amazing tool to manage external dependencies. ]]></description> <link>http://steven.thuriot.be/nuget-as-a-plugin-deployment-platform</link> <guid isPermaLink="true">http://steven.thuriot.be/nuget-as-a-plugin-deployment-platform</guid> <pubDate>2013-12-18T20:39:00+00:00</pubDate> <content:encoded><![CDATA[<p><a href="http://www.nuget.org/">NuGet</a> has become quite popular among .NET developers. As described in one of my earlier posts, it is an amazing tool to manage external dependencies.</p> <p>It&#39;s not just a mere dependency manager, though. No, it is so much more! The <a href="http://www.nuget.org/packages/Nuget.Core/">NuGet core framework</a> is available as NuGet package itself. This Core Framework allows you to use NuGet&#39;s packaging abilities together with it&#39;s deployment strategy to basically do whatever you want.</p> <p>One of the possibilities is plugin deployment. In this post, I will explain how to do this. But first, I will explain how I got to investigating this technology.</p> <h1>Background info</h1> <p>I&#39;m currently working on a project that quickly allows you to build modules. These modules are then loaded by a hoster shell through MEF and automagically turned into a navigational tree.</p> <p>Spreading the modules with the hoster can quickly become quite the hassle. Most commonly, this would be done through a clickonce solution. The problem with this, however, is that the clickonce package can quickly become quite large and may contain other modules that do not interest our user.</p> <p>By (ab)using NuGet, we can let the user browse through a gallery and let them pick out the modules they want to use. When a new version of a certain module is released, the user can simply update that one single module, instead of having to download the entire clickonce package again.</p> <h1>The code</h1> <p>And now, finally, comes the interesting part. The code!</p> <p>First, we select a location to save our plugins. The easiest way to do this, is by using a common folder in the location of our entry assembly (the hoster executable).</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="kt">var</span> <span class="n">entryAssembly</span> <span class="p">=</span> <span class="n">Assembly</span><span class="p">.</span><span class="n">GetEntryAssembly</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">location</span> <span class="p">=</span> <span class="n">entryAssembly</span><span class="p">.</span><span class="n">Location</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">pluginDirectory</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FileInfo</span><span class="p">(</span><span class="n">location</span><span class="p">).</span><span class="n">Directory</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">pluginFolder</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="n">Combine</span><span class="p">(</span><span class="n">pluginDirectory</span><span class="p">.</span><span class="n">FullName</span><span class="p">,</span> <span class="s">&quot;Modules&quot;</span><span class="p">);</span>
</code></pre></div> <p>Now that we know where we&#39;re going to save our packages, we can intialize our repository. This can be done in a single line of code.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="kt">var</span> <span class="n">repository</span> <span class="p">=</span> <span class="n">PackageRepositoryFactory</span><span class="p">.</span><span class="n">Default</span><span class="p">.</span><span class="n">CreateRepository</span><span class="p">(</span><span class="s">@&quot;http://novamodules.apphb.com/nuget&quot;</span><span class="p">);</span>
</code></pre></div> <p>We will now query the repository to retrieve the packages. Usually, we are only interested in the latest packages.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="kt">var</span> <span class="n">plugins</span> <span class="p">=</span> <span class="n">repository</span><span class="p">.</span><span class="n">GetPackages</span><span class="p">().</span><span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">IsLatestVersion</span><span class="p">).</span><span class="n">ToList</span><span class="p">();</span>
</code></pre></div> <p>This list of plugins can then be shown to our user, who can then select which plugins to install or update. Installing the plugins themselves, can also be done in only a few lines of code.</p> <p>First we create a package manager. Using this manager, we can then install, update or uninstall the packages of our choice.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="kt">var</span> <span class="n">manager</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PackageManager</span><span class="p">(</span><span class="n">repository</span><span class="p">,</span> <span class="n">pluginFolder</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">plugin</span> <span class="k">in</span> <span class="n">plugins</span><span class="p">)</span>
        <span class="n">manager</span><span class="p">.</span><span class="n">InstallPackage</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
</code></pre></div> <p>Uninstalling the packages can be tricky, however, since .NET will most likely be using them. A way around this, is by loading them into a different appdomain with ShadowCopy enabled. This can, however, quickly become quite difficult. An easier solution would be to simply move the package into another folder and simply clean up that folder every time your application starts.</p> <p>The packages can now easily be loaded up as plugins using MEF&#39;s <a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.composition.hosting.directorycatalog.aspx">DirectoryCatalog</a>. Because of the way NuGet installs packages, the easiest way to retrieve the plugins is by retrieving all the &quot;lib&quot; folders in our Modules directory and creating an aggregate of DirectoryCatalogs.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="kt">var</span> <span class="n">catalogs</span> <span class="p">=</span> <span class="n">pluginDirectory</span><span class="p">.</span><span class="n">GetDirectories</span><span class="p">(</span><span class="s">&quot;lib&quot;</span><span class="p">,</span> <span class="n">SearchOption</span><span class="p">.</span><span class="n">AllDirectories</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">DirectoryCatalog</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">FullName</span><span class="p">));</span>
    <span class="kt">var</span> <span class="n">directoryAggregate</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AggregateCatalog</span><span class="p">(</span><span class="n">catalogs</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CompositionContainer</span><span class="p">(</span><span class="n">directoryAggregate</span><span class="p">);</span>
</code></pre></div> <p>From now on, deploying your modules will be easier than ever!</p> ]]></content:encoded> </item> </channel> </rss>