<?xml version="1.0" encoding="UTF-8"?> <rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"> <channel> <title><![CDATA[Steven Thuriot.be &mdash; TypeReference]]></title> <description><![CDATA[Thoughts, stories and ideas.]]></description> <link>http://steven.thuriot.be</link> <link href="//steven.thuriot.be/tag/typereference/rss/" rel="self" type="application/rss+xml"/> <ttl>60</ttl> <item> <title><![CDATA[Playing with Generic References: Hidden features of C#]]></title> <description><![CDATA[When writing generic classes, it&#39;s highly likely you&#39;ve gotten to the point (at least once) where you had to write a piece of type-specific code (wether due to third party or not) and you&#39;ve done a type-check in one of your methods. Depending on the type of your generic parameter, you&#39;ve then set a certain course of action. ]]></description> <link>//steven.thuriot.be/generic-references</link> <guid isPermaLink="true">//steven.thuriot.be/generic-references</guid> <pubDate>2015-08-19T19:17:00+00:00</pubDate> <media:content url="//cdn.thuriot.be/images/Covers/surprise.jpg" medium="image"/> <content:encoded><![CDATA[<p>When writing generic classes, it&#39;s highly likely you&#39;ve gotten to the point (at least once) where you had to write a piece of type-specific code (wether due to third party or not) and you&#39;ve done a type-check in one of your methods. Depending on the type of your generic parameter, you&#39;ve then set a certain course of action.</p> <p>Code smells aside, you&#39;ve probably bumped into a casting issue at this point.</p> <p>Imagine a generic class that holds some data.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">ClassWithData</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">_value</span><span class="p">;</span>

  <span class="c1">// other stuff</span>

  <span class="k">public</span> <span class="kt">byte</span><span class="p">[]</span> <span class="nf">GetBytes</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">//Shit hits the fan if we want to stay in safe code...</span>
    <span class="c1">//and we&#39;ll do something like this:</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">_value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">double</span><span class="p">))</span>
      <span class="c1">//and so on ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>Of course, this example won&#39;t even compile. The compiler won&#39;t let you cast to the generic type, even though you&#39;ve verified it to be correct and in fact, the same! A cast which isn&#39;t really a cast in the first place.</p> <p>Usually, we solve this by boxing the generic value first, and thus tricking the compiler.</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">ClassWithData</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">_value</span><span class="p">;</span>

  <span class="c1">// other stuff</span>

  <span class="k">public</span> <span class="kt">byte</span><span class="p">[]</span> <span class="nf">GetBytes</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="c1">//Tricking the compiler!</span>
      <span class="kt">int</span> <span class="k">value</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">object</span><span class="p">)</span><span class="n">_value</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">double</span><span class="p">))</span>
      <span class="c1">//and so on ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>Bam! Code compiles, code works. Job done. Or is it? Not only are we tricking the compiler, we are also tricking ourselves... Doing this will box the generic value, moving it from the stack to the heap. This process is slow and should be avoided.</p> <p>It&#39;s a problem (given you want to keep your code this way in the first place) that is actually easily solved. We can circumvent this by using a few of C#&#39;s undocumented keywords: <code>__makeref</code> and <code>__refvalue</code>.</p> <p><code>__makeref</code> will create a <code>TypeReference</code>, while <code>__refvalue</code> will cast the reference to the type you pass it. No boxing and unboxing involved!</p> <p>Implemented it would look like this:</p> <div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">ClassWithData</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">_value</span><span class="p">;</span>

  <span class="c1">// other stuff</span>

  <span class="k">public</span> <span class="kt">byte</span><span class="p">[]</span> <span class="nf">GetBytes</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="kt">var</span> <span class="n">tr</span> <span class="p">=</span> <span class="n">__makeref</span><span class="p">(</span><span class="n">_value</span><span class="p">);</span>
      <span class="kt">int</span> <span class="k">value</span> <span class="p">=</span> <span class="n">__refvalue</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">//no typeof here..!</span>
      <span class="k">return</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">double</span><span class="p">))</span>
      <span class="c1">//and so on ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>I have noticed that it&#39;s rather picky with its casts, so be careful! For instance, if the type of <code>_value</code> is a <code>string</code>, and you&#39;re calling <code>__refvalue</code> with <code>object</code> as a type, it will throw an exception. Even though in normal code, that would work without any issues!</p> <p>This definitely needs to be properly unit-tested when used in your project.</p> <p>Enjoy, and don&#39;t forget to check back for more adventures later!</p> ]]></content:encoded> </item> </channel> </rss>